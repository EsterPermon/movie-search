{"version":3,"file":"static/js/160.0d8f8439.chunk.js","mappings":"mBAAO,MCIMA,EAAqBC,MAAOC,EAAeC,EAAkBC,WACjDC,MAAM,GAADC,ODLN,2BCKkB,YAAAA,ODHnB,WCGqC,UAAAA,OAASH,EAAI,OAAAG,OAAMJ,EAAK,UAAAI,OAASF,KAC3EG,OCFlBC,UAAYP,UAGV,MAAM,KAAEE,EAAI,QAAEM,GAAYC,EAAMC,KAEhC,OAAQR,GACN,IAAK,eACH,IACE,MAAMS,QAAeC,EAAaJ,EAAQK,KAAML,EAAQN,MAClDY,EAAaC,KAAKC,OAAY,OAANL,QAAM,IAANA,OAAM,EAANA,EAAQM,QCXhB,IDW2C,EACjEC,YAAY,CAAEhB,KAAM,YAAaM,QAAS,CAAEW,gBAAiBR,EAAQG,eACvE,CAAE,MAAOM,GACHA,aAAiBC,OACnBH,YAAY,CAAEhB,KAAM,QAASM,QAASY,EAAME,SAEhD,CACA,MAEF,IAAK,WAAY,CACf,MAAMC,EAAgBC,EAAehB,EAAQiB,YAAajB,EAAQW,iBAClED,YAAY,CAAEhB,KAAM,aAAcM,QAASe,IAC3C,KACF,EAGF,EAGF,MAAMX,EAAeZ,MAAO0B,EAAoBC,KAC9C,MAAMC,QAAmB7B,EAAmB2B,EAAYC,EAAY,GAEpE,GAA4B,SAAxBC,EAAWC,SAAqB,CAClC,MAAMC,EAAcC,SAASH,EAAWI,cAElCC,EAAgBlB,KAAKC,MAAMc,ECnCE,IDmCuC,EAE1E,OAAOI,EAAmBD,EAAeP,EAAYC,EACvD,CACA,MAAM,IAAIN,MAAMO,EAAWP,MAAM,EAG7Ba,EAAqBlC,MAAOiC,EAAuBP,EAAoBC,KAC3E,MAAMQ,EAAqB,GAG3B,IAAK,IAAIC,EAAI,EAAGA,GAAKH,EAAeG,IAAK,CACvC,MAAMR,QAAmB7B,EAAmB2B,EAAYC,EAAYS,GAEpE,GAA4B,SAAxBR,EAAWC,SAAqB,CAClC,MAAMQ,GAAmB,OAAVT,QAAU,IAAVA,OAAU,EAAVA,EAAYU,SAAU,GACrCH,EAAUI,QAAQF,EACpB,CACF,CAEA,OADqBF,EAAUK,KAAKC,EACjB,EAGfC,EAAWC,GACRA,EAAKC,MAAM,EAAG,GAGjBH,EAAqBA,CAACI,EAAeC,KACzC,MAAMC,EAAaL,EAAQG,EAAOG,MAC5BC,EAAaP,EAAQI,EAAOE,MAElC,OAAID,IAAeE,EACVJ,EAAOK,MAAQJ,EAAOI,OAAS,EAAI,EAErCH,EAAaE,GAAc,EAAI,CAAC,EAGnCzB,EAAiBA,CAAC2B,EAAkBC,KACxC,MAAMC,EC1EsB,ID0ERF,EAAW,GACzBG,EAAWD,EC3EW,GD6EtBE,EAAYH,EAAeR,MAAMS,EAAYC,GACnD,OAAOE,EAAiBD,EAAU,EAI9BC,EAAoBC,GACZ,OAALA,QAAK,IAALA,OAAK,EAALA,EAAOC,QAAO,CAACC,EAA2BC,KAC/C,MAAMjB,EAAOD,EAAQkB,EAAKZ,MAEpBa,EAAa,OAAJD,QAAI,IAAJA,OAAI,EAAJA,EAAME,OAKrB,OAJKH,EAAYhB,KACfgB,EAAYhB,GAAQ,CAAC,GAEvBgB,EAAYhB,GAAMkB,GAAUD,EACrBD,CAAW,GACjB,CAAC,E","sources":["api/medias/constants.ts","api/medias/index.ts","workers/worker.ts","workers/types.ts"],"sourcesContent":["export const BASE_URL = 'https://www.omdbapi.com/';\n\nexport const API_KEY = '8ea39b15';\n","import { SearchType } from '../../workers/types';\nimport { API_KEY, BASE_URL } from './constants';\nimport type { MediaDetailsInfo, MediaPagination } from './types';\n\nexport const fetchMediasByTitle = async (title: string, type: SearchType, page: number): Promise<MediaPagination> => {\n  const response = await fetch(`${BASE_URL}?apikey=${API_KEY}&type=${type}&s=${title}&page=${page}`);\n  return response.json();\n};\n\nexport const fetchMediaByImdbId = async (imdbId: string): Promise<MediaDetailsInfo> => {\n  const response = await fetch(`${BASE_URL}?apikey=${API_KEY}&i=${imdbId}`);\n  return response.json();\n};\n","import { fetchMediasByTitle } from '../api/medias';\nimport { Media } from '../api/medias/types';\nimport { ITEMS_PER_PAGE, MainThreadEventType, MediasByYear, OMDB_API_ITEMS_PER_PAGE, SearchType } from './types';\n\nonmessage = async (event: MessageEvent<MainThreadEventType>) => {\n  // console.log('Received message from the main thread:', event.data);\n\n  const { type, payload } = event.data;\n\n  switch (type) {\n    case 'searchMedias': {\n      try {\n        const result = await searchByTerm(payload.term, payload.type);\n        const totalPages = Math.floor(result?.length / ITEMS_PER_PAGE) + 1;\n        postMessage({ type: 'allMedias', payload: { allMediasSorted: result, totalPages } });\n      } catch (error) {\n        if (error instanceof Error) {\n          postMessage({ type: 'error', payload: error.message });\n        }\n      }\n      break;\n    }\n    case 'loadPage': {\n      const groupedMedias = loadMediasPage(payload.currentPage, payload.allMediasSorted);\n      postMessage({ type: 'pageMedias', payload: groupedMedias });\n      break;\n    }\n    default:\n      break;\n  }\n};\n\nconst searchByTerm = async (searchTerm: string, searchType: SearchType) => {\n  const mediasData = await fetchMediasByTitle(searchTerm, searchType, 1);\n\n  if (mediasData.Response === 'True') {\n    const mediasCount = parseInt(mediasData.totalResults);\n    // calculates how many fetches will be necessary to retrieve all records\n    const fetchesAmount = Math.floor(mediasCount / OMDB_API_ITEMS_PER_PAGE) + 1;\n\n    return fetchAndSortMedias(fetchesAmount, searchTerm, searchType);\n  }\n  throw new Error(mediasData.Error);\n};\n\nconst fetchAndSortMedias = async (fetchesAmount: number, searchTerm: string, searchType: SearchType) => {\n  const allMedias: Media[] = [];\n\n  // Run all necessary fetches until all records are retrieved\n  for (let i = 1; i <= fetchesAmount; i++) {\n    const mediasData = await fetchMediasByTitle(searchTerm, searchType, i);\n\n    if (mediasData.Response === 'True') {\n      const medias = mediasData?.Search || [];\n      allMedias.push(...medias);\n    }\n  }\n  const sortedMedias = allMedias.sort(sortByYearAndTitle);\n  return sortedMedias;\n};\n\nconst getYear = (year: string) => {\n  return year.slice(0, 4);\n};\n\nconst sortByYearAndTitle = (mediaA: Media, mediaB: Media) => {\n  const mediaAYear = getYear(mediaA.Year);\n  const mediaBYear = getYear(mediaB.Year);\n\n  if (mediaAYear === mediaBYear) {\n    return mediaA.Title < mediaB.Title ? -1 : 1;\n  }\n  return mediaAYear > mediaBYear ? -1 : 1;\n};\n\nconst loadMediasPage = (currPage: number, allItemsSorted: Media[]) => {\n  const startIndex = (currPage - 1) * ITEMS_PER_PAGE;\n  const endIndex = startIndex + ITEMS_PER_PAGE;\n\n  const itemsPage = allItemsSorted.slice(startIndex, endIndex);\n  return groupItemsByYear(itemsPage);\n};\n\n// Given a media array already sorted, group it by year\nconst groupItemsByYear = (items: Media[]): MediasByYear => {\n  return items?.reduce((accumulator: MediasByYear, item: Media) => {\n    const year = getYear(item.Year);\n\n    const imdbId = item?.imdbID;\n    if (!accumulator[year]) {\n      accumulator[year] = {};\n    }\n    accumulator[year][imdbId] = item;\n    return accumulator;\n  }, {});\n};\n\nexport {};\n","import { Media } from '../api/medias/types';\n\nexport const ITEMS_PER_PAGE = 20;\nexport const OMDB_API_ITEMS_PER_PAGE = 10;\n\nexport type MediasByYear = Record<string, Record<string, Media>>;\nexport type SearchType = '' | 'movie' | 'series';\n\ntype SearchMedias = { type: 'searchMedias'; payload: { term: string; type: SearchType } };\ntype LoadPage = { type: 'loadPage'; payload: { currentPage: number; allMediasSorted: Media[] } };\nexport type MainThreadEventType = SearchMedias | LoadPage;\n\ntype SendAllMedias = { type: 'allMedias'; payload: { allMediasSorted: Media[]; totalPages: number } };\ntype SendPageMedias = { type: 'pageMedias'; payload: MediasByYear };\ntype ReportError = { type: 'error'; payload: string };\nexport type WorkerEventType = SendAllMedias | SendPageMedias | ReportError;\n"],"names":["fetchMediasByTitle","async","title","type","page","fetch","concat","json","onmessage","payload","event","data","result","searchByTerm","term","totalPages","Math","floor","length","postMessage","allMediasSorted","error","Error","message","groupedMedias","loadMediasPage","currentPage","searchTerm","searchType","mediasData","Response","mediasCount","parseInt","totalResults","fetchesAmount","fetchAndSortMedias","allMedias","i","medias","Search","push","sort","sortByYearAndTitle","getYear","year","slice","mediaA","mediaB","mediaAYear","Year","mediaBYear","Title","currPage","allItemsSorted","startIndex","endIndex","itemsPage","groupItemsByYear","items","reduce","accumulator","item","imdbId","imdbID"],"sourceRoot":""}